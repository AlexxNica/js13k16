<meta charset=utf-8><title>Super Chrono Portal Maker</title><body bgcolor=0><center><canvas width=1280 height=648 style="border:1px Q;background:#5C94FC;cursor:crosshair"id=a>
<img src="data:;base64,iVBORw0KGgoAAAANSUhEUgAAA1QAAAAQCAMAAAAmns6IAAAAWlBMVEUAAADFycoAAADjnSWAgID///+xNCVHSUECRYe6YRHJu5wAqADITAz8vLBIAP//slkCa9Mpzv+A0BDEUU9qawSKjsBCQv+wtOb3ORD/AABhY1rIzP4BIkP/2bLDllwqAAAAAnRSTlMAOrCfFIoAAAY2SURBVHhe1duJkqQ2DAZg5Qf6mPveI8n7v2Yk2SCQxjbQM53kT6eNQHZtde1XZpheWhdwUnF3bwG/+mGR/m8XiqFf8/F5EaLzIkTvi5AGGjsGHY80nUtjruDy6IJGCC+c29sXHfiV86KB+/O0czo9Sf5Kw+lEKdXZ5xS6OF1HBIBovhxyxoJmB4C/muOKbcvEMxRmxjntdWINxAabbUfhRLXffQC+KOSksRq3nNR9f2fB/R2Ghaoe5zOyh3REkkcJIio1NZ///HF+XATvfy4iqkYZCc0N53j8/ft4lCPRJLiR3imZsOCnC16qWYMKSKeA70F1HlNCVr9sDROqsXRQahpQQYUty2jgz4SZkcO6dSy16wGVo13tb30aBVPQnMyUBp+imqvq8SmqEcho6ddsZFPPU4aBUQkZnqgzBJWw+vHjh5ISVEpqGLJTKCmJsoKaAjBoQBAJ2YKimrymI8yI3MasQKWkhkG7C47G7EfVcQIyX4fSNxyYUQek5fSdYEFVAyqosGkZq+2Mnxk7aOU6ltqEIirtq/a39m2g+ZegjWrop6CECktUQxp7RfU8i6CSyGTbqRRVOnhXU4pKAkalpDKrhEpdFVCpJTWVjmBkzIypaaPKpkxVNIWc0+mPXagUATqHLNShDA2Hg6A6nM/g9dhYRkWcogaKV+PN0MZlDIoTSlTsoPY6oUPjUaahjAomPPRbUfo0iqiecr4IlZoyVYxJUYFHh2pYhWqIqI4cQ6UpoVJL6f3n16Aa1JSqQsGUqdqFqkuJyGJtZVR5yKgOnUbGhROnoVjG1q3L6OC5glPuoNXraIqoYrMF83zaH7X64ut3qpiIilBCNaxApaYUlQZImDh6AAyLwMc8yfvFqNQUh0lpEEy57EBF+W4tIPN1KH2DoIKgOnO4cn8xL9up6IJlbBMo6129TpRYs24xNfANbjvduVOd9C0+qCAA9Z1KAturIiowqkFt8ThHNexBRWzp+Pp6c/P6KkekqKAv26r4lSCA7M5Pj/4XqKjTRGRwtSv9hENCRbxDAUzM/dSw4UEFuWsRlcW11jA0UbXXsdA+VPYW+81U9dNoo3L+5En6hArYg4obGRVkVFRm6nkNKomh0v3pVaOHc1QooMqm9OhyVJwaqqdFdqE6HB705ZEBEV0srWFcgdfi4iFV2PpIPaKi9aioiopWo6ImKnfBzS+iKhDdgIraqIYU7c23f0kVAAG2H1U/ojJTK1FpqqjALxkjqp8uqGcdqkHzXagOI6qDnZEagDVM5rqDlmO7qVRFGqmsXPUsnOgKOxVnJSpqo8J3ocIX7FQR1Z2gElEyXI7KTBmqR8BQKaZ3QxVv/27E1I3d/mk+RxXSMNVGNaoq7VSnWTaiMkGqxNxIAHRmquNX3pPAdSf9+bJGVRG9Ef/P13TOm2NQv0H69p+pNC1UZGnh/C5U+IKfqSKqe3D4gLP9QQWSJh50ZFRmar5TPbqdioeAapgeVLApPcBGVE00m27/BkG1NOkRtVHBgsQEGrlno3RCUQCdqVt2i0Ft1+6ESpJRsSo1xYVlNypaj4quhor2PqhoUa9tlJp1qCigkq8qlVC5J+pxp8qYdFBUZmrP7V/lkbqaugoqizuB7ajwOAvy3qOoOlWiKDSUw0JSi5m06zqd8lbGjnS+Fv8mKutGu6OGyrquhMpUXYaKHCrNalSmClRApabWovKJv/y13/5eA1UjW1HBRVQASdGI6iGFTJW2jNWDTuMGRYMOkEKTUVnhfhVj5TZUxXmxtC47WtERUcWua6AyVReioiqqHlP6Aqpw99fLoGFQM1OMKgMEpq8p2c9UXGBYBPFrSuk0hiuhGhaBqz0ql4jKzyeiBCYrUhNakoUZkRDJ5hJRRaMQZIb1S6fWCZWFYhlR5QRUFmqjIrj+ZkdEFbv2oMrZgooAP30XKiqhAsSUpY+oJGaKsiX0OSLJ8tH4Qm1EZV+ohX2hdgzov4fqaf7fKlTJy6RGBqum4k27xtFakinyiVB8uQWVm1dFFXm2O6KPyPxqqGgXqilcFG5P7saxxyKujGp7F/pYhODy7gKXwj/9SKEroKpnOyoXY2JaQvXGCVcc15YqX25C5ea1UZET0+qIqHzXFVFRA9U/0X8GNpca52UAAAAASUVORK5CYII"hidden id=b>
<script>

// Globals
// =======
  
// Canvas context 2D
c = a.getContext("2d");

// Init local storage to 1 if it's not already set
localStorage["scpm"] = localStorage["scpm"] || 1;

// Current screen (0: main menu / 1: level selection / 2: playing / 3: editor)
d = 0;

// Previous screen (when we quit a level, 0: when playing a G level / 1: when playing a built-in level / 3: whe testing a level in the level eitor)
n = 0;

// Mouse down (player is clicking)
o = false;

// Player is right clicking
p = false;

// Mouse coords (in px)
x = y = 0;

// Current level
s = 0;

// keys state
aa = ab = ac = 0;

// Chrono
_ = 0;

// loop
ad = 0;

// All the data of the current level
t = {};

// Built-in levels:
levels = [

// 0
,
  
// 1
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000200\
0000065656000000000000000060000600000000\
0000000000000000400400000000000000000000\
0F00000000000004400440000000000000000000\
0G00000000000044400444000070000700000400\
3333333333333333300333333333333333333333\
3333333333333333300333333333333333333333",pipes:[[]],balances:[],txt:"Move with arrow keys or WASD or ZQSD. Collect all coins and reach the flag.",record:215},

// 2
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000060060060000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000060060000000000000000000020\
0000000050050050050000400040000000000000\
0F00000000000000000004400044000000000000\
0G00000000000000000044400044400077000000\
3333333333333333333333333333333333333333\
3333333333333333333333333333333333333333",pipes:[],balances:[],txt:"If you're stuck, restart with R.",record:377},

// 3
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000060000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000040040040080080000020\
0000060060060000400000000000000000000000\
0F00000000000004440000000000000000000000\
0G00000000000044444000000000000000000000\
3338888888888888888888888888888888888333\
3338888888888888888888888888888888888333",pipes:[],balances:[],txt:"Ice is slippy if you're not standing still.",record:254},

// 4
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000600000000000000000000000000000\
0000000000000000000000000000000000000020\
0000000000600000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000600000<00000000000000000000000\
0000000000000000000000004000000004000000\
0000<00<00400000000000044000000004400000\
0F00000000440000000000444000000004440000\
0G00000000444000000004444000000004444000\
3333333333333333033333333333333333333333\
3333333333333333333333333333333333333333",pipes:[],balances:[],txt:"Press space to hold and drop cubes. Jump and press space to throw them.",record:530},

// 5
{hash:"0000000000000000000000000000000000000000\
00000000<0000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000999900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000:::900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000999900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000:::900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000666900000000000000000000000000002\
0000000000900000<00000000000000000000000\
0000000999900000500000000000000000000004\
0000000000900000000000000000000000000004\
0F00000000900000000000000000000000000004\
0G0;000000900;000000;00000000000;0000004\
33333333333333333999999933333::::::33333\
33333333333333333999999933333::::::33333",pipes:[],balances:[],txt:"Yellow switches are all connected.",record:1111},

// 6
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000033333333333000\
0000000044000000000000000000000000000000\
0000000000000000000060000000000000000000\
000000000000600000000000000<000000200000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000300000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0F00000000000000000000000000000000000000\
0G00000000000000000000000000000000000000\
3333333333333333333333333333333333333333\
3333333333333333333333333333333333333333",pipes:[[8,8,16,6,16],[24,16,6,22,16],[35,7,16,30,5]],balances:[],txt:"Each green switch controls one pipe.",record:724},

// 7
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000<00000000000\
0000000000000000000000000000000000000000\
0000000000000000000009999999990000000000\
0000000000000000000000000000000000000020\
0000000000000000000000000000000000000000\
00F0000000000000000000000000000000000000\
00G0000000000000000000000000000000000000\
3333330000000000000000000000000000000000\
3333330000000000000000000000000000000000\
0000000000000000000000000000000000000040\
000000000000000000;000060000000000000040\
0000000000000000333330060000000000000040\
0000000000000000333330060000000033333333\
0000000000000000000000000000000033333333\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[[8,9,13,17],[28,6,23,14]],record:306},

// 8
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0444444444444400000000000000000000000000\
0300000000000000000000000000000000000040\
0306060606000000000000000000000000006040\
03000000000<0000000000000000000000000040\
0300000000000000000000000000000000000040\
0300000444444400000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000020000000000040\
0300000300000000000000000000000000000040\
0400F00400000000000000000000000000000040\
0400G0040000000000000000000000000000;040\
044444440000000000000000003::::::::33330\
0000000000000000000000000000000000000000",pipes:[],balances:[],txt:"Aim with mouse, send ag with left click and right click.",record:342},

// 9
{hash:"0000000000000000000000000000000000000000\
0444400000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000006000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000200\
0400000000000000000000000000000000000000\
040000F000000000000000000000000000000000\
040000G000000000000000000000000000000000\
0444444444444000000000000888888888888880\
0000000000000000000000000000000000000000",pipes:[],balances:[],txt:"Use momentum!",record:208},

// 10
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000008888888888888888888800000000000\
0000000003000000000000000000800000000000\
0000000003000000000000000000800000000000\
0000000003002000000000000000800000000000\
0000000003000000000000000000800000000000\
0000000003000000000006000000800000000000\
0000000003000007700000000000800000000000\
0000000004444444444444060000800000000000\
0000000003000000000000000000800000000000\
0000000003000000000006000000800000000000\
0000000003000000000000000000800000000000\
0000000003000000000000000000800000000000\
000000000300F000000000000000800000000000\
000000000300G000000000000000800000000000\
0000000004444444444444000000800000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[],record:266},

// 11
{hash:"0000000000000000000000000000000000000000\
0888888888888888888888888888888888888880\
0800000000000000000000000000000000000080\
0800000000000000000000000000000000000080\
08998000000000000000000000000000008:::80\
08998000000000000000000000000000008:::80\
08998000000000000000000000000000008:::80\
0800800000000000000000000000000000800080\
0800800000000000000000000000000000800080\
0800800000000000000000000000000000800080\
0800800000004333333333330000000000800080\
0800800000044300000300000006666660800080\
0800800000444300000300000000000000800080\
0800833333333300000300200033333333800080\
0800800000000000000400000000000000000080\
080000000000000F000400000000000000000080\
080000000000000G0;0400000000000000000080\
0800000000000033333333330000000000000080\
0000000000000000000000000000000000000000",pipes:[],balances:[],record:589},

// 12
{hash:
"0000000000000000004400000000000000000000\
0000000000000000000000000000000000000000\
000000000000000002F000000000000000000000\
000000000000000000G000000000000000000000\
0000000000000000033000000000000000000000\
0000000000000000000000000000000000000000\
0000000000006000000000006000000000000000\
0000000000000000000000000000000000000000\
0000000000060000000000000060000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000006000000000000000\
0000000000006000000000000000000000000000\
0000000000000000000000000000000000000000\
00000000000000000<6000000000000000000000\
0000000000000000033000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000044000000000000000000",pipes:[],balances:[[],[19,7,24,4],[19,9,24,15],[19,11,14,15],[19,13,14,4]],record:541},

// 13
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000002030000000\
0000000000000000000000000000000030000000\
0000000000000000000000000000000030000000\
0000000000000000000000033333333330000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000030600000000000030000000000000000\
0000000030000000F00000030000000000000000\
0000000030000000G00000030000000000000000\
0000000033333333333333330000000000000000\
0000000000000000000000000000000000000000",pipes:[[21,16,8,10,16]],balances:[],txt:"Need a little help from the past? Go to the time machine and press Shift!",record:262},

// 14
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000020000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000006660000000\
0000000000000000000000000000000000000000\
0000000000000000000060000000000000000000\
0000000000000000000000000333009990000000\
000000000000000000600::00000000000000000\
00000000000000000000:::00000000000000000\
0000000000000000600::::00000000000000000\
000000000000000000:::::00000000000000000\
00000000000000600::::::00000000000000000\
0000000000000000:::::::00000000000000000\
000000000000600::::::::00000000000000000\
00000000000000:::::::::00000000000000000\
00000F0000600::::::::::00000000000000000\
00000G00;000:::::::::::00000000000000000\
3333333333333333333333333333333333333333\
3333333333333333333333333333333333333333",pipes:[],balances:[],record:309},

// 15
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000200000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000003000000000000\
0000000000000000000000000003000000000000\
0000000000000000000000003333000000000000\
0000000000000000000000003000000000000000\
0000000000000000000000003000000000000000\
0000000000000000000000003000000000000000\
0000000000000000000000003000000000000000\
0000000000030F00000000003000000000000000\
0000000000030G00000<00003000000000000000\
0000000000033333333333333000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[],record:168},

// 16
{hash:"00000000000000000000000<0000000000000000\
0000000000000200000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000004000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000F00000000000\
0000000000000000000000000000G00000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000003333333333333333333333300000000\
0000000000000000000000000000000000000000",pipes:[],balances:[],record:403},

// 17
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000003000000000000000000003000000000\
0000000003000000606060606060603000000000\
0000000003000000000000000000003000000000\
00000000030999::::::::::::::::3000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000203000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
00000000030000000000000000F0003000000000\
0000000003000000;000000000G0003000000000\
0000000003333333333333333333333000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",pipes:[[11,15,7,21,15]],balances:[],txt:"Sometimes you need to make multiple time travels...",record:736},

// 18
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000006000000\
0000000000000000000000000000000006000000\
0000000000000000000000000000000006000000\
000000000000000000000000000;;;;;;;000000\
0000000000000000000000000003333333000000\
0000002000000000000000000003000000000000\
0000000000000000000000000003000000000000\
0000030000000000000000000003000000000000\
00000300F0000000000000000003000000000000\
00000300G0000000000000000003000000000000\
0000033333399999999999933333000000000000\
0000000000300000000000030000000000000000\
0000000000300000000000030000000000000000\
0000000000300000000000030000000000000000\
0000000000333333333333330000000000000000\
0000000000000000000000000000000000000000",pipes:[[25,12,7,17,12]],balances:[],txt:"If a past self dies or can't reach the time machine, it's a paradox! *Ik Ik theme*",record:739},

// 19
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000203000000000000\
0000000000000000000000000003000000000000\
0000000000000000000000003333000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000030F00000000000000000000000000000\
0000000030G000<00<00<0000000000000000000\
0000000033333333333333330000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[],record:596},

// 20
{hash:"0000000000000000000000000000000000000000\
0000000000000000000<00000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000200000000000000\
000000000F000000000000000000000000000000\
000000000G000000000000000000000000000000\
0000000333330000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000<00033330000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
000000000000000000<0<0000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000333333000000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[[14,4,19,16]],txt:"Heros and cubes have the same weight.",record:995},

// 21
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000003444300000344430000000009000000000\
0000003000300000300030000000009000000000\
0000000000300000000000000000009000000000\
0000000000300000000000000000009000000000\
0000000000300;00000000000000009000000000\
0033300000333330000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009020000000\
0000000000000000000000000000009000000000\
00F0000000000000000000000000009000000000\
00G0000000000000000000000000009000000000\
0444444444444444444444444444444444400000\
0000000000000000000000000000000000000000",pipes:[[24,3,16,3,7]],balances:[[8,12,18,12]],txt:"Only two ag can exist at the same time.",record:1545},

// 22
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000=00000000000000000000\
0000000006060606060=00000000000000000000\
0000000000000000000=00000000000000000000\
0000000000033333333333330000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000200000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000400000000000000000000000000\
000000000000444000000F000000000000000000\
000000300004444400000G000000003000000000\
0000003333333333333333333333333000000000\
0000000000000000000000000000000000000000",pipes:[[24,16,6,19,16]],balances:[[]],txt:"Clouds will block all your future selves!",record:579},

// 23
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000006000000000000002000\
000F000000000000000060600000000000000000\
000G00;000000000000000000000000000000000\
003333339990:::09990:::09990:::333333300\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[],txt:"Count in your head: 1-2-3-switch! 1-2-3-switch! I know, this one's terrible.",record:497},

// 24
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000200000\
0000000000000000000000033333333300000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
000000000000000000<000000000000000000000\
0000000000000000099900000000000000000000\
0000000000000000000000000000000000000000\
0000000000000=00000000000000000000000000\
0000000000000=00000000030000000000000000\
00000003000F0=00000000030000000000000000\
00000003300G0=00000000030000000000000000\
0300000333333333333333330000000003330000\
0330;00000000000000000000000000000000000\
0333333000000000000000000333000000000000\
0000000000000000000000000000000000000000",pipes:[[21,14,5,26,16]],balances:[],txt:"You can grab and throw cubes even if they're not here yet...",record:609},

// 25
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000044440000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000200\
000000009=000000000000000000000000000000\
000000009=000006000000040000000000000000\
00000F009=000000000000040000000000000000\
00000G009=000007000000040000000000000000\
0000333333333333333344440000000000000000\
0000300000000000000000000000000000000000\
00;0300000000000000000000000000000008880\
0333300000000000000000000000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[],txt:"You can aim and shoot ag even if you're not here yet...",record:611},

// 26
{hash:"000F000000000000000000000000000000000000\
000G000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000700700000000707000000000000000000000\
0040404440<00400444000000000000000000000\
0047404000400400404000000000000000000000\
0044404400400400404000000000000000000000\
0040404000470470404000000000000000000000\
0040404440440440444000000000000000000000\
0000000000000000000000000000000000020000\
0000000000000000000666066006006606000000\
0000000000000000000888088068008808000000\
0000000000000000000080080088000808000000\
00===========000006080088008008808680000\
0000000000000000008080008008000808800000\
0000000000000000008880088088808808080000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",pipes:[],balances:[[33,5,24,5],[27,5,30,5]],record:507},

// 27
{hash:"00000000000000000=0000000000000000000000\
00000000000000000=0F00003000000000000000\
00003333333330000=0G0;003000000000000000\
0000300000009000033333333000000000000000\
0000300000009000030000000000000000000000\
0000300000009000330000000000000000000000\
0000300033333333330000000000000000000000\
0000300000000000333333333333333333333330\
0000300000000000300000000090000000000030\
0000300000000000302000000090000000000030\
0333333333333300300000000090000000000030\
030000000:000000300000000070000000000030\
030000000:000000333444444444444444400030\
030000000:000000300000000000000000000030\
0300333333333333300600000000000000000030\
0300000000000000000000000000000000000030\
03000000000000000000004000000040<0000030\
0338888888888888888334400000004433333330\
0000000000000000000000000000000000000000",pipes:[[36,16,8,34,16]],balances:[],record:1777},

// 28
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
00000000000000=0000000009000000000000000\
00000000000000=0020F00099000000000000000\
00000000000000=0000G00999000:00000000000\
0000000000000055555555555000000000000000\
000000000000000000454000000000:000000000\
0000000000000000004540000000000000000000\
0000000000000000004540000000:00000000000\
0000000000000000004540000000000000000000\
000000000000000000454000000000:000000000\
0000000000000000004540000000000000000000\
0000000000000000004540000000:00000000000\
0000000000000000004540000000000000000000\
000000000000000000454000000000:000000000\
0000000000000006004540060000000000000000\
0000000000000000004540000000:00000000000\
0000000<000000000045400;0000000000000000\
0000005555555599955555555555555550000000",pipes:[[12,17,5,15,17]],balances:[],record:715},

// 29
{hash:"0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000200000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
00000000000<0<0<0<0300000000000000000000\
000000000F000000000300000000000000000000\
000000000G000000000300000000000000000000\
0000000033333333333333333333300000000000",pipes:[],balances:[],txt:"By the way, did you notice that           cubes can glitch through walls?  ",record:632},

// 30
{hash:"0033333000000000000000000000000000000<00\
0030F03000000000<<0000000000000000000000\
0030G0300000<<00000000<<0000<00000040000\
00300030000000<<0000<<000000000002000000\
0030003000000000<<0000<<0000000000000000\
003000300000<<0000<<00000000000000000000\
00300030000000<<0000<<000000000004000000\
003000300000<<00000000<<0000000000000000\
00300030000000<<000000000000000000000000\
003000300000<<00000000<<0000000000000000\
00300030000000<<0000<<000000000000000000\
003000300000<<00000000000000000000000000\
0030003000000000000000<<0000000000000000\
00000000000000<<0000<<000000000000000000\
000000000000<<00000000<<0000000000000000\
0000000000000000000000000000000000000000\
0000000000007777000077770000000000000000\
0008888888888888888888888888888888800000\
0000000000000000000000000000000000000000",pipes:[[16,16,8,19,7],[18,16,8,16,7],[33,11,16,28,5]],balances:[[4,3,36,1],[4,4,37,6],[4,5,37,11],[4,6,37,16],[4,7,9,16],[4,8,-1,16],[4,9,1,-1],[28,4,28,6]],txt:"Thanks for playing! Please create and share levels now!",record:735}

];

// Helpers
// =======

// Draw a 32x32 tile aligned on the grid
draw_tile = (id, q, r) => {
  c.drawImage(b, id * 16, 0, 16, 16, q * 32, 40 + r * 32, 32, 32);
}

// Draw a 32x32 sprite anywhere (don't forget to add 40 to y to draw in the scene)
draw_sprite = (id, x, y) => {
  c.drawImage(b, id * 16, 0, 16, 16, x, y, 32, 32);
}

// Which tile is at these coordinates (in px)? (returns 0 by default)
tile_at = (x, y) => {
  if(!t.x[~~(y / 32)]){
    return 0;
  }
  return t.x[~~(y / 32)][~~(x / 32)] || 0;
}

// Set a tile in the current level at these coordinates (in px)
set_tile = (x, y, value) => {
  if(!t.x[~~(y / 32)]){
    return;
  }
  t.x[~~(y / 32)][~~(x / 32)] = value;
}

// Is a tile id currently Q? 
// Clouds are Q after a time travel
// (optionally, consider spikes Q, because cubes can be placed on them)
is_Q = (id, spikes) => {
  if(id == 13){
    document.title = ae.length + " " + Z + " " + N;
  }
  return (id == 13 && Z != 0) || (spikes && id == 7) || Q[id] || 0;
}

// Is a tile writable (in the editor, a.k.a don't already contain a pipe or a balance or a time machine)
is_writable = (q, r) => {
  if(!t.x[r]){
    return 0;
  }
  return !t.x[r][q] || t.x[r][q] < 14 || t.x[r][q] > 21
}

// Reset a Z (after starting a level / reversing time)
reset_Z = () => {

  return {
    x: (t && t.start) ? t.start[0] * 32 : 640,
    y: (t && t.start) ? t.start[1] * 32 : 0,
    e: 0,
    f: 0,
    d: 0,
    ab: ab || false,
    j: [],
    m: aa || false,
    l: [],
    ac: ac || false,
    g: [],
    r: [],
    shift: [],
    C: [],
    z: [],
    angle: 0,
    i: 1, // 0: left, 1: right
    a: 0, // 0: idle, 1: walking, 2: jumping, 3: dead
    t: null,
    o: null,
    position_on_cube: null,
    v: 0,
    n: true
  }
}

// Reset all the settings of the current level (before playing : 0 / before going back in time: 1)
reset_current_level = (timetravel) => {
  
  // Reset I condition
  I = false;
  M = 0;
  J = 0;
  K = 0;
  L = 0;

  // Current N
  N = 0;

  // Reset "present" Z
  O = reset_Z();

  // Qity of the tiles (some of them vary during gameplay, so we reset it before each level and after reset)
  Q = [
    0, // 0: sky
    0, // 1: time machine placeholder
    0, // 2: flag
    1, // 3: ground
    1, // 4: portalable wall
    1, // 5: brick
    0, // 6: coin
    0, // 7: spike
    1, // 8: ice
    1, // 9: Q yellow block
    0, // 10: non-Q yellow block
    0, // 11: yellow toggle
    0, // 12: cube
    0, // 13: cloud
    1, // 14: pipe placeholder
    0, // 15: Balance
    1, // 16: pipe top left
    1, // 17: pipe top right
    1, // 18: pipe body left
    1, // 19: pipe body right
    1, // 20: Green switch
    0, // 21: Green switch pressed
    0, // 22: Tardis top
    0, // 23: Tardis bottom
    0, // 24: flag pole
    0  // 25: yellow toggle pressed
  ];
  
  // Cubes (parsed at N 0)
  t.u = [];
  
  // Yellow toggles state at last N
  U = false
  
  // Pipes state
  V = [];
  
  // Balances state
  W = [];
  
  // Portals
  X = { q: -1, r: -1 };
  Y = { q: -2, r: -2 };
  
  // Heros (playing simultaneously after time travels)
  if(!timetravel){
    ae = [];
  }
}

// Make an empty level (for the editor)
reset_maker_level = () => {
  
  // Editor's level data
  t = {
    x: [],
    pipes: [],
    balances: [],
    u: [],
    tested: false
  }

  for(j = 0; j < 20; j++){
    t.x[j] = [];
  }

  // Pipes
  pipe_click = 0;
  v = 0;

  // Balances
  w = 0;
  z = 0;
  
  // Current tile in the level editor (0: sky / 1: start / etc.)
  A = 0;
  
  // Reset ability to quit
  G = true;
  H = false;
};

// First N inits (also happen after time travels)
first_N = () => {
  
  reset_current_level(1);
    
  // Build map from hash
  t.x = [];
  for(var j = 0; j < 20; j++){
    t.x[j] = [];
    for(var i = 0; i < 40; i++){
      
      t.x[j][i] = t.hash.charCodeAt(j * 40 + i) - 0x30;

      // Ignore tile #15 / "?" / balanced platforms placeholders.
      if(t.x[j][i] == 15){
        t.x[j][i] = 0
      }
    }
  }
  
  // Init pipes states
  for(var i in t.pipes){
    V[i] = {pressed: false, y: t.pipes[i][1] * 32};
  }
  
  // Init balances states (on first N)
  for(var i in t.balances){
    W[i] = {y1: t.balances[i][1] * 32 , y2: t.balances[i][3] * 32, weight1: 0, weight2: 0};
  }
}

// Parse and draw map (at each N, but if we're on N 0, also set start coordinates, initialize cubes and build flag pole)
parse_draw_map = () => {
  for(j = 0; j < 20; j++){
    for(i = 0; i < 40; i++){
      
      // Current tile
      F = t.x[j][i];
      
      // Tile #12: cube (register it in t.u and remove it from the tiles)
      if(F == 12){
        F = 0;
        if(N == 0){
          t.u.push({x: i * 32, y: j * 32, f: 0, Z: null});
        }
      }
      
      // Tile #13 and not time traveled yet: transparent cloud
      if(F == 13 && ae.length == 0){
        c.save();
        c.globalAlpha = 0.5;
        draw_tile(F, i, j);
        c.restore();
      }
      
      // Else, any tile is opaque
      else {
        draw_tile(F, i, j);
      }
      
      // Tile #2: flag pole (make it touch the ground)
      if(F == 2 && N == 0){
        E = false;
        if(j < 20){
          for(k = j + 1; k < 20; k++){
            if(!t.x[k][i] && !E){
              draw_tile(24, i, k);
              t.x[k][i] = 24;
            }
            else{
              E = true;
            }
          }
        }
      }
      
      // Tile #23: time machine (save starting point coordinates, place Z there at first N)
      if(F == 23 && N == 0){
        t.start = [i, j];
        O.x = t.start[0] * 32;
        O.y = t.start[1] * 32;
      }
    }
  }
  
  // N 0: re-place all past ae at the start position and reset their movement properties
  if(N == 0){
    
    for(Z in ae){
      ae[Z].x = t.start[0] * 32;
      ae[Z].y = t.start[1] * 32;
      ae[Z].e = 0;
      ae[Z].f = 0;
      ae[Z].ab = false;
      ae[Z].m = false;
      ae[Z].ac = false;
      ae[Z].q = false;
      ae[Z].i = 1;
      ae[Z].s = 0;
      ae[Z].t = null;
      ae[Z].o = null;
      ae[Z].position_on_cube = null;
    }
    for(i in t.u){
      t.u[i].Z = null;
    }
  }
}

// Apply gravity and collisions to a given object (type 0: Z, type 1: cube), plus make it enter in ag
gravity_and_collisions = (obj, obj_width, type) => {
  
  // compute object's weight
  if(typeof obj.t != "undefined" && obj.t !== null){
    obj.weight = 1 + t.u[obj.t].weight;
  }
  
  // Follow the cube below and forget it until next N
  if(obj.o !== null && obj.o != obj.t){
    obj.x = t.u[obj.o].x + obj.position_on_cube;
    obj.y = t.u[obj.o].y - 32;
    obj.o = null;
  }

  // Go right
  if(obj.e > 0){
    
    obj.portal_af = null;
    
    // Enter a portal on the right (tile 4 + portal on position 3 (left) + other portal exists)
    if(
      tile_at(obj.x + obj_width + obj.e, obj.y + 16) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((obj.x + obj_width + obj.e) / 32)
      &&
      X.r == ~~((obj.y + 16) / 32)
      &&
      X.side == 3
    ){
      obj.portal_af = Y;
    }
    
    if(
      tile_at(obj.x + obj_width + obj.e, obj.y + 16) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((obj.x + obj_width + obj.e) / 32)
      &&
      Y.r == ~~((obj.y + 16) / 32)
      &&
      Y.side == 3
    ){
      obj.portal_af = X;
    }
    
    // If the object is entering a portal
    if(obj.portal_af){
      
      // Adjust position and speed
      obj.y = ~~((obj.y + 16) / 32) * 32;
      obj.f = 0;
      obj.k = true;
      
      // Teleport and maintain the speed for a few Ns if the object's left side entered the portal's tile
      if(tile_at(obj.x + obj.e, obj.y + 16) == 4){
        obj.teleport = true;
        obj.momentum = Math.max(obj.e, 6);
        obj.e = 0;
        obj.c = 8;
      }
    }
    
    // Stop going right if there's a Q tile or the end of the screen on the right
    else if(
      is_Q(tile_at(obj.x + obj_width + obj.e, obj.y))
      ||
      is_Q(tile_at(obj.x + obj_width + obj.e, obj.y + 31))
    ){
      obj.x = ~~((obj.x + obj.e) / 32) * 32 + 32 - obj_width - 1;
      obj.e = 0;
    }
    
    if(obj.x > 1280 - obj_width){
      obj.x = 1280 - obj_width;
      obj.e = 0;
    }
    
    // Stop going right if there's a pipe there
    for(var j in t.pipes){
      if(
        !obj.k
        &&
        obj.x + obj_width + obj.e >= t.pipes[j][0] * 32
        &&
        obj.x + obj_width + obj.e  <= t.pipes[j][0] * 32 + 16
        &&
        obj.y + 31 >= V[j].y
        &&
        obj.y <= V[j].y_base
      ){
        obj.x = t.pipes[j][0] * 32 - obj_width - 1;
        obj.e = 0;
      }
    }
  }
  
  // Go left
  if(obj.e < 0){
  
    obj.portal_af = null;
    
    // Enter a portal on the left (tile 4 + portal on position 1 (right) + other portal exists)
    if(
      tile_at(obj.x + obj.e, obj.y + 16) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((obj.x + obj.e) / 32)
      &&
      X.r == ~~((obj.y + 16) / 32)
      &&
      X.side == 1
    ){
      obj.portal_af = Y;
    }
    
    if(
      tile_at(obj.x + obj.e, obj.y + 16) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((obj.x + obj.e) / 32)
      &&
      Y.r == ~~((obj.y + 16) / 32)
      &&
      Y.side == 1
    ){
      obj.portal_af = X;
    }
      
    // If the object is entering a portal
    if(obj.portal_af){
      
      // Adjust position and speed
      obj.y = ~~((obj.y + 16) / 32) * 32;
      obj.f = 0;
      obj.k = true;
      
      // Teleport and maintain the speed for a few Ns if the object's right side entered the portal's tile
      if(tile_at(obj.x + obj.e + obj_width, obj.y + 16) == 4){
        obj.teleport = true;
        obj.momentum = Math.max(-obj.e, 6);
        obj.e = 0;
        obj.c = 8;
      }
    }
    
    // Stop going left if there's a Q tile or end of the level on the left
    else if(
      is_Q(tile_at(obj.x + obj.e, obj.y))
      ||
      is_Q(tile_at(obj.x + obj.e, obj.y + 31))
    ){
      obj.x = ~~((obj.x + obj.e) / 32) * 32 + 32;
      obj.e = 0;
    }
    if(obj.x < 0){
      obj.x = 0;
      obj.e = 0;
    }
    
    // Stop going left if there's a pipe there
    for(j in t.pipes){
      if(
        obj.x + obj.e >= t.pipes[j][0] * 32 + 64 - 16
        &&
        obj.x + obj.e <= t.pipes[j][0] * 32 + 64
        &&
        obj.y + 31 >= V[j].y
        &&
        obj.y <= V[j].y_base
      ){
        obj.x = t.pipes[j][0] * 32 + 64;
        obj.e = 0;
      }
    }
  }
  
  // Apply horizontal speed
  obj.x += obj.e;
  
  // Apply gravity if object is not in a portal, and compute vertical speed
  if(!obj.k){
    obj.d = false;
    obj.f += 2;
    if(obj.f > 24){
      obj.f = 24;
    }
  }
  
  // Go down
  if(obj.f > 0){
    
    obj.portal_af = null;
    
    // Enter a portal on the bottom (tile 4 + portal on position 0 (top) + other portal exists)
    if(
      tile_at(obj.x + obj_width / 2, obj.y + 32 + obj.f) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((obj.x + obj_width / 2) / 32)
      &&
      X.r == ~~((obj.y + 32 + obj.f) / 32)
      &&
      X.side == 0
    ){
      obj.portal_af = Y;
    }
    
    if(
      tile_at(obj.x + obj.e / 2, obj.y + 32 + obj.f) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((obj.x + obj_width / 2) / 32)
      &&
      Y.r == ~~((obj.y + 32 + obj.f) / 32)
      &&
      Y.side == 0
    ){
      obj.portal_af = X;
    }
      
    // If the object is entering a portal
    if(obj.portal_af){
      
      // Adjust position and speed
      obj.x = ~~((obj.x + obj_width / 2) / 32) * 32 + (32 - obj_width) / 2;
      obj.e = 0;
      obj.k = true;
      
      // Teleport and maintain the speed for a few Ns if the object's top side entered the portal's tile
      if(
        // Low speed
        (obj.f < 10 && tile_at(obj.x + obj_width / 2, obj.y + 32 + obj.f - 16) == 4)
        ||
        
        // High speed
        (obj.f > 10 && tile_at(obj.x + obj_width / 2, obj.y + 32 + obj.f) == 4)
      ){
        obj.teleport = true;
        obj.momentum = Math.max(obj.f, 6);
        obj.f = 0;
        obj.c = 8;
      }
    }
  
    // Stop falling if a Q tile is under object (or a spike, if the object is a cube)
    else if(
      is_Q(tile_at(obj.x, obj.y + 32 + obj.f))
      ||
      is_Q(tile_at(obj.x + obj_width - 1, obj.y + 32 + obj.f))
      ||
      (type == 1 && tile_at(obj.x, obj.y + 32 + obj.f) == 7)
      ||
      (type == 1 && tile_at(obj.x + obj_width - 1, obj.y + 32 + obj.f) == 7)
    ){
      obj.y = ~~((obj.y + obj.f) / 32) * 32;
      obj.f = 0;
      obj.d = true;
    }
    
    // Stop falling if a cube is under object (only if the cube and the object are not in a portal)
    for(i in t.u){
      if(
        !t.u[i].k
        &&
        !obj.k
        &&
        obj.x + obj_width > t.u[i].x
        &&
        obj.x < t.u[i].x + 32
        &&
        obj.y + 31 + obj.f > t.u[i].y - 8
        &&
        obj.y + 31 + obj.f < t.u[i].y + 20
      ){
        obj.y = t.u[i].y - 32;
        obj.f = 0;
        obj.d = true;
        obj.o = i;
        obj.position_on_cube = obj.x - t.u[i].x;
        t.u[i].weight += obj.weight;
      }
    }
    
    // Stop falling if there's a pipe there
    for(j in t.pipes){
      if(
        obj.x + obj_width - 1 >= t.pipes[j][0] * 32
        &&
        obj.x < t.pipes[j][0] * 32 + 64
        &&
        obj.y + 31 + obj.f >= V[j].y
        &&
        obj.y + 31 + obj.f <= V[j].y + 32
      ){
        obj.y = V[j].y - 32;
        obj.f = 0;
        obj.d = true;
        obj.b = true;
      }
    }
    
    // Stop falling if there's a balance "1" there
    for(j in t.balances){
      if(
        obj.x + obj_width >= t.balances[j][0] * 32 - 32
        &&
        obj.x < t.balances[j][0] * 32 + 64
        &&
        obj.y + 31 + obj.f >= W[j].y1 - 8
        &&
        obj.y + 31 + obj.f <= W[j].y1 + 32
      ){
        obj.y = W[j].y1 - 32;
        obj.f = 0;
        obj.d = true;
        obj.b = true;
        W[j].weight1 += obj.weight;
      }
    }
    
    // Stop falling if there's a balance "2" there
    for(j in t.balances){
      if(
        obj.x + obj_width >= t.balances[j][2] * 32 - 32
        &&
        obj.x < t.balances[j][2] * 32 + 64
        &&
        obj.y + 31 + obj.f >= W[j].y2 - 8
        &&
        obj.y + 31 + obj.f <= W[j].y2 + 32
      ){
        obj.y = W[j].y2 - 32;
        obj.f = 0;
        obj.d = true;
        obj.b = true;
        W[j].weight2 += obj.weight;
      }
    }
  }
  
  // Go up (only for Z)
  if(obj.f < 0){
    
    obj.portal_af = null;
    
    // Enter a portal on top (tile 4 + portal on position 2 (bottom) + other portal exists)
    if(
      tile_at(obj.x + obj_width / 2, obj.y + obj.f) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((obj.x + obj_width / 2) / 32)
      &&
      X.r == ~~((obj.y + obj.f) / 32)
      &&
      X.side == 2
    ){
      obj.portal_af = Y;
    }
    
    if(
      tile_at(obj.x + obj.e / 2, obj.y + obj.f) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((obj.x + obj_width / 2) / 32)
      &&
      Y.r == ~~((obj.y + obj.f) / 32)
      &&
      Y.side == 2
    ){
      obj.portal_af = X;
    }
      
    // If the object is entering a portal
    if(obj.portal_af){
      
      // Adjust position and speed
      obj.x = ~~((obj.x + obj_width / 2) / 32) * 32 + (32 - obj_width) / 2;
      obj.e = 0;
      obj.k = true;
      
      // Teleport and maintain the speed for a few Ns if the object's bottom side entered the portal's tile
      if(tile_at(obj.x + obj_width / 2, obj.y + obj.f + 10) == 4){
        obj.teleport = true;
        obj.momentum = 6;
        obj.f = 0;
        obj.c = 8;
      }
    }
    
    // Stop going up if there's a Q tile on top (only for Z)
    else if(
      is_Q(tile_at(obj.x, obj.y + obj.f))
      ||
      is_Q(tile_at(obj.x + obj_width, obj.y + obj.f))
    ){
      
      // Break bricks (tile #5 => tile #0)
      if(tile_at(obj.x, obj.y + obj.f) == 5){
        set_tile(obj.x, obj.y + obj.f, 0);
        mkaudio(SNDbrick1).play();
      }
      if(tile_at(obj.x + 24, obj.y + obj.f) == 5){
        set_tile(obj.x + 24, obj.y + obj.f, 0);
        mkaudio(SNDbrick1).play();
      }
      
      obj.y = ~~((obj.y + obj.f) / 32) * 32 + 32;
      obj.f = 0;
    }
  }
  
  // Update position according to vertical speed
  obj.y += obj.f;
  
  
  // Teleport
  if(obj.teleport){
    obj.teleport = false;
    obj.d = false;
    
    obj.x = obj.portal_af.q * 32 + (32 - obj_width) / 2;
    obj.y = obj.portal_af.r * 32;
    
    // Top 
    if(obj.portal_af.side == 0){
      obj.f = -obj.momentum;
      obj.e = 0;
    }
    
    // right
    if(obj.portal_af.side == 1){
      obj.e = obj.momentum;
      obj.f = 0;
      obj.x += 8;
    }
    
    // bottom
    if(obj.portal_af.side == 2){
      obj.f = obj.momentum;
      obj.e = 0;
      
      // Ensure the Z falls off the portal and is controllable soon
      obj.y += 8;
      obj.c = 2;
    }
    
    // left
    if(obj.portal_af.side == 3){
      obj.e = -obj.momentum;
      obj.f = 0;
      obj.x -= 8;
    }
  }
  
  // Press yellow switch (at the bottom left or right)
  if(tile_at(obj.x, obj.y + 20) == 11){
    set_tile(obj.x, obj.y + 20, 25);
    R = true;
  }
  else if(tile_at(obj.x + obj_width, obj.y + 20) == 11){
    set_tile(obj.x + obj_width, obj.y + 20, 25);
    R = true;
  }
  
  // Press green switch
  for(var i in t.pipes){
    if(
      obj.x + obj_width >= t.pipes[i][3] * 32
      &&
      obj.x <= t.pipes[i][3] * 32 + 32
      &&
      obj.y + 32 >= t.pipes[i][4] * 32
      &&
      obj.y + 20 <= t.pipes[i][4] * 32 + 32
    ){
      V[i].pressed = true;
    }
  }
}

// Play or replay a given Z (past: 1 / present: 0)
play_Z = (this_Z, past) => {
  
  // If he's not dead and didn't I yet
  if(this_Z.a != 3 && !I && !L){
    
    // Reset to idle state, consider he's not on a moving object
    this_Z.a = 0;
    this_Z.b = false;
    
    // If we're not in the few Ns that follow a portal teleportation
    if(!this_Z.c){

      // Cancel vx (if Z not on ice and not in the air or in the air but without horizontal momentum)
      if(
        (
          this_Z.d
          &&
          tile_at(this_Z.x, this_Z.y + 33) != 8
          &&
          tile_at(this_Z.x + 24, this_Z.y + 33) != 8
        )
        ||
        (
          !this_Z.d
          &&
          Math.abs(this_Z.e) < 10
        )
      ){
        this_Z.e = 0;
      }
    
      // Go right (unless if in portal, or being teleported, or slipping left on ice)
      if(
        this_Z.g[N]
        &&
        !(
          (
            tile_at(this_Z.x, this_Z.y + 33) == 8
            ||
            tile_at(this_Z.x + 24, this_Z.y + 33) == 8
          )
          &&
          this_Z.e != 0
        )
      ){
        if(this_Z.i == 1){
          this_Z.e = Math.max(this_Z.e, 6);
        }
        else {
          this_Z.e = 0
        }
        this_Z.i = 1;
        
        // Walk animation
        if(this_Z.d){
          this_Z.a = 1;
        }
      }
      
      // Go left (unless if in portal, or being teleported, or slipping right on ice)
      if(
        this_Z.j[N]
        &&
        !(
          (
            tile_at(this_Z.x, this_Z.y + 33) == 8
            ||
            tile_at(this_Z.x + 24, this_Z.y + 33) == 8
          )
          &&
          this_Z.e != 0
        )
      ){
        if(this_Z.i == 0){
          this_Z.e = Math.min(this_Z.e, -6);
        }
        else {
          this_Z.e = 0
        }
        this_Z.i = 0;
        
        // Walk animation
        if(this_Z.d){
          this_Z.a = 1;
        } 
      }
    }
    
    // Jump (if not in a portal and not slipping on ice)
    if(
      !this_Z.k
      &&
      this_Z.l[N]
      &&
      this_Z.d
      &&
      !(
        (
          tile_at(this_Z.x, this_Z.y + 33) == 8
          ||
          tile_at(this_Z.x + 24, this_Z.y + 33) == 8
        )
        &&
        this_Z.e != 0
      )
    ){
      this_Z.f -= 20;
      this_Z.d = false;
      this_Z.m = false;
      this_Z.n = false;
      this_Z.o = null;
      mkaudio(SNDjump2).play();
    }
    
    // Jump sprite
    if(this_Z.f < 0 && !this_Z.d){
      this_Z.a = 2;
    }
    
    // Apply gravity and collsions
    gravity_and_collisions(this_Z, 24, 0);
    
    // Collect coins (tile 6 => tile 0)
    if(tile_at(this_Z.x + 24 / 2 - 8, this_Z.y + 16 - 8) == 6 ){
      set_tile(this_Z.x + 24 / 2 - 8, this_Z.y + 16 - 8, 0);
      mkaudio(SNDcoin1).play();
    }
    if(tile_at(this_Z.x + 24 / 2 + 8, this_Z.y + 16 - 8) == 6){
      set_tile(this_Z.x + 24 / 2 + 8, this_Z.y + 16 - 8, 0);
      mkaudio(SNDcoin1).play();
    }
    if(tile_at(this_Z.x + 24 / 2 - 8, this_Z.y + 16 + 8) == 6){
      set_tile(this_Z.x + 24 / 2 - 8, this_Z.y + 16 + 8, 0);
      mkaudio(SNDcoin1).play();
    }
    if(tile_at(this_Z.x + 24 / 2 + 8, this_Z.y + 16 + 8) == 6){
      set_tile(this_Z.x + 24 / 2 + 8, this_Z.y + 16 + 8, 0);
      mkaudio(SNDcoin1).play();
    }
    
    // Press Shift
    if(this_Z.shift[N]){
      
      // If in front of the time machine (tile #23)
      if(
        tile_at(this_Z.x, this_Z.y) == 23
        ||
        tile_at(this_Z.x + 24, this_Z.y) == 23
        ||
        tile_at(this_Z.x, this_Z.y + 31) == 23
        ||
        tile_at(this_Z.x + 24, this_Z.y + 31) == 23
      ){
        
        // Present Z: remember the N and add it to the array of past ae and go back to the beginning of time (N -1)
        if(!past){
          this_Z.p = N;
          ae.push(this_Z);
          N = -1;
          O = reset_Z();
        }
        
        // Past Z: remember that he's safe
        else{
          this_Z.q = true;
        }
        
        mkaudio(SNDtimetravel0).play();
      }
    }
    
    // Die (spike)
    if(
      tile_at(this_Z.x + 3, this_Z.y) == 7
      ||
      tile_at(this_Z.x + 24 - 3, this_Z.y) == 7
      ||
      tile_at(this_Z.x + 3, this_Z.y + 5) == 7
      ||
      tile_at(this_Z.x + 24 - 3, this_Z.y + 5) == 7
    ){
      this_Z.a = 3;
      this_Z.f = -1 * 20;
    }
    
    // Die (fall)
    if(this_Z.y > 648){
      this_Z.a = 3;
      this_Z.f = -1.5 * 20;
    }
    
    // Die (if a Q yellow block (#9) appears on top of the Z)
    if(
      (tile_at(this_Z.x + 1, this_Z.y + 1) == 9)
      ||
      (tile_at(this_Z.x + 24 - 1, this_Z.y + 1) == 9)
      ||
      (tile_at(this_Z.x + 1, this_Z.y + 31) == 9)
      ||
      (tile_at(this_Z.x + 24 - 1, this_Z.y + 31) == 9)
    ){
      this_Z.a = 3;
      this_Z.f = -1.5 * 20;
    }
    
    // Die (crush between a pipe or a balance and a Q tile)
    if(
      this_Z.b
      &&
      (
        (
          is_Q(tile_at(this_Z.x, this_Z.y + 1))
          ||
          is_Q(tile_at(this_Z.x + 24, this_Z.y + 1))
        )
      )
    ){
      this_Z.a = 3;
      this_Z.f = -1 * 20;
    }
    
    // Pick/drop cube toggle
    if(this_Z.r[N]){
      this_Z.s ^= 1;
    }
    
    // Pick cube
    if(this_Z.s){
      if(this_Z.t === null){
        for(i in t.u){
          if(
            this_Z.x + 24 >= t.u[i].x
            &&
            this_Z.x <= t.u[i].x + 31
            &&
            this_Z.y + 31 + 4 >= t.u[i].y
            &&
            this_Z.y <= t.u[i].y + 31
          ){
            this_Z.t = i;
            t.u[i].Z = this_Z;
            this_Z.pick_cube_animation_N = 5;
            break;
          }
        }
      }
    }
    
    // Drop cube
    else if($ = t.u[this_Z.t]){
      
      $.x = this_Z.x;
      $.o = null;

      // Throw it if Z is not grounded
      if(!this_Z.d){
        
        // Left
        if(this_Z.i == 0){
          $.e = -14;
        }
        
        // Right
        else{
          $.e = 14;
        }
      }
      
      // Avoid collisions
      if(is_Q(tile_at($.x, $.y))){
        $.x = ~~(($.x) / 32) * 32 + 32;
      }
      else if(is_Q(tile_at($.x, $.y + 31))){
        $.x = ~~(($.x) / 32) * 32 + 32;
      }
      else if(is_Q(tile_at($.x + 32, $.y))){
        $.x = ~~(($.x) / 32) * 32 - 1;
      }
      else if(is_Q(tile_at($.x + 32, $.y + 31))){
        $.x = ~~(($.x) / 32) * 32 - 1;
      }
        
      $.Z = null;
      t.u[this_Z.t] = $;
      this_Z.t = null;
      this_Z.weight = 1;
    }
    
    // Hold cube
    if(this_Z.t !== null){
      
      // Left
      if(this_Z.i == 0){
        t.u[this_Z.t].x = this_Z.x - 6;
      }
      if(this_Z.i == 1){
        t.u[this_Z.t].x = this_Z.x - 4;
      }
      
      // Animate cube grab (make it last 5 Ns)
      if(this_Z.pick_cube_animation_N){
        this_Z.pick_cube_animation_N--;
      }
      
      // Place cube over Z (unless he's passing through a portal or there's a Q tile above, in this case hold it lower)
      if(this_Z.k){ 
        t.u[this_Z.t].y = this_Z.y;
      }
      else if(is_Q(tile_at(this_Z.x, this_Z.y - 28)) || is_Q(tile_at(this_Z.x + 24, this_Z.y - 28))){
        t.u[this_Z.t].y = ~~((this_Z.y + 4) / 32) * 32;
      }
      else{
        t.u[this_Z.t].y = this_Z.y - 32 + this_Z.pick_cube_animation_N * 4;
      }
    }
    
    // If no cube is held, cancel space key
    else {
      this_Z.s = 0;
    }
    
    // I (all coins gathered and touch flag)
    if(tile_at(this_Z.x + 24 / 2, this_Z.y + 16) == 2 || tile_at(this_Z.x + 24 / 2, this_Z.y + 16) == 24){
      M = 0;
      for(j = 0; j < 20; j++){
        for(i = 0; i < 40; i++){
          if(t.x[j][i] == 6){
           M++;
          }
        }
      }
      if(M == 0){
        I = true;
        this_Z.a = 0;
      }
    }
    
    // Send ag (only if Z's not currently in a portal)
    if(!this_Z.k && (this_Z.C[N] || this_Z.z[N])){
        
      // Cancel current shoots
      this_Z.shoot_blue = 0;
      this_Z.shoot_orange = 0;
      
      // Left click: current Z sends a blue portal
      if(this_Z.C[N]){
        this_Z.shoot_blue = 1;
        
        // Compute the angle made by the line "Z - click coordinates" and the horizontal axis
        this_Z.angle = Math.atan2(this_Z.C[N][0] - (this_Z.x + 24 / 2), this_Z.C[N][1] - (this_Z.y + 40 + 16));
      }
      
      // Right click: current Z sends a orange portal
      if(this_Z.z[N]){
        this_Z.shoot_orange = 1;
        
        // Compute the angle made by the line "Z - click coordinates" and the horizontal axis
        this_Z.angle = Math.atan2(this_Z.z[N][0] - (this_Z.x + 24 / 2), this_Z.z[N][1] - (this_Z.y + 40 + 16));
      }
      
      // Compute portal beam movement
      this_Z.portal_shoot_x = this_Z.x + 24 / 2;
      this_Z.portal_shoot_y = this_Z.y + 16;
      this_Z.portal_shoot_vx = Math.sin(this_Z.angle);
      this_Z.portal_shoot_vy = Math.cos(this_Z.angle);
    }
    
    // Portal beam (reflect on ice / open portal on white wall)
    for(ah in ag = [["shoot_blue", X, "blue"], ["shoot_orange", Y, "orange"]]){
    
      if(this_Z[ag[ah][0]]){
      
        // Make beam advance with baby steps
        for(i = 0; i < 40; i++){
          this_Z[ag[ah][0]] += .001;
          this_Z.portal_shoot_x += this_Z[ag[ah][0]] * this_Z.portal_shoot_vx;
          this_Z.portal_shoot_y += this_Z[ag[ah][0]] * this_Z.portal_shoot_vy;
          
          // If beam hits Q or spike (tile #7)
          if(is_Q(tile_at(this_Z.portal_shoot_x, this_Z.portal_shoot_y)) || tile_at(this_Z.portal_shoot_x, this_Z.portal_shoot_y) == 7){
            
            // Cancel any existing portal of this color
            this_Z[ag[ah][0]] = 0;
            
            // Define on which side the portal goes (0: top, 1: right, 2: bottom, 3: left)
            // Avoid opening a portal between two Q tiles, and on sides not reachable given the current angle
            if(this_Z.portal_shoot_x % 32 < 4 && !is_Q(tile_at(this_Z.portal_shoot_x - 32, this_Z.portal_shoot_y)) && this_Z.portal_shoot_vx > 0){
              m = 3;
            }
            if(this_Z.portal_shoot_x % 32 > 28 && !is_Q(tile_at(this_Z.portal_shoot_x + 32, this_Z.portal_shoot_y)) && this_Z.portal_shoot_vx < 0){
              m = 1;
            }
            if(this_Z.portal_shoot_y % 32 < 4 && !is_Q(tile_at(this_Z.portal_shoot_x, this_Z.portal_shoot_y - 32)) && this_Z.portal_shoot_vy > 0){
              m = 0;
            }
            if(this_Z.portal_shoot_y % 32 > 28 && !is_Q(tile_at(this_Z.portal_shoot_x, this_Z.portal_shoot_y + 32)) && this_Z.portal_shoot_vy < 0){
              m = 2;
            }

            // Reflect ray if tile is #8 (ice)
            if(tile_at(this_Z.portal_shoot_x, this_Z.portal_shoot_y) == 8){
              this_Z[ag[ah][0]] = 1;
              if(m == 0){
                this_Z.portal_shoot_vy = -this_Z.portal_shoot_vy;
                this_Z.portal_shoot_y = ~~(this_Z.portal_shoot_y / 32) * 32 - 1;
              }
              else if(m == 2){
                this_Z.portal_shoot_vy = -this_Z.portal_shoot_vy;
                this_Z.portal_shoot_y = ~~(this_Z.portal_shoot_y / 32) * 32 + 32 + 1;
              }
              else if(m == 1){
                this_Z.portal_shoot_vx = -this_Z.portal_shoot_vx;
                this_Z.portal_shoot_x = ~~(this_Z.portal_shoot_x / 32) * 32 + 32 + 1;
              }
              else
              {
                this_Z.portal_shoot_vx = -this_Z.portal_shoot_vx;
                this_Z.portal_shoot_x = ~~(this_Z.portal_shoot_x / 32) * 32 - 1;
              }
            }
            
            // Place portal if tile is #4 (white wall) and no orange portal is here yet
            if(
              tile_at(this_Z.portal_shoot_x, this_Z.portal_shoot_y) == 4
              &&
              (~~(this_Z.portal_shoot_x / 32) != ag[1 - ah][1].q || ~~(this_Z.portal_shoot_y / 32) != ag[1 - ah][1].r || ag[1 - ah][1].side != m)
            ){
              ag[ah][1].q = ~~(this_Z.portal_shoot_x / 32);
              ag[ah][1].r = ~~(this_Z.portal_shoot_y / 32);
              ag[ah][1].side = m;
            }
            break;
          }
          else{
            c.fillStyle = ag[ah][2];
            c.fillRect(this_Z.portal_shoot_x, this_Z.portal_shoot_y + 40, 6, 6);        
          }
        }
      }
    }
    
    // If Z is not in a #4 Q tile, assume he's not in a portal
    if(
      tile_at(this_Z.x + 1, this_Z.y + 1) != 4
      &&
      tile_at(this_Z.x + 24 - 1, this_Z.y + 1) != 4
      &&
      tile_at(this_Z.x + 1, this_Z.y + 31) != 4
      &&
      tile_at(this_Z.x + + 24 - 1, this_Z.y + 31) != 4
    ){
      this_Z.k = false;
    }
    
    // Decrement teleportation idle delay
    if(this_Z.c){
      this_Z.c--;
    }
  }
  
  // Death animation
  if(this_Z.a == 3){
    this_Z.f += 2;
    if(this_Z.f > 24){
      this_Z.f = 24;
    }
    this_Z.y += this_Z.f;
  }
}

// Draw a Z (past: 1 / present: 0)
draw_Z = (Z, past) => {
  c.save();
  
  // Go to the Z's position
  c.translate(Z.x + 24 / 2 - 2, Z.y);
  
  // Facing left
  if(Z.i == 0){
    c.scale(-1, 1);
  }
    
  // Past: alpha 0.5
  if(past){
    c.globalAlpha = 0.75;
  }
  
  // Present and past ae exist: add arrow to present
  else if(ae.length){
    c.fillStyle = "#fff";
    c.fillText("▼", 0, 10);
  }

  // Draw (except if it's a past Z that has finished playing)
  if(! (past && N > Z.p)){
    c.drawImage(b, [26, [27,28,29][~~(N / 2) % 3], 30, 31][Z.a] * 16, 0, 16, 16, - 24 / 2, 40, 32, 32);
  }
  
  c.restore();
}

// Input
// =====

// Handle clicks on the canvas on each screen
onclick = oncontextmenu = (e) => {
  handle_clicks(e);
  return false;
}

// On mouse down, set a mousedown flag and a rightclick flag (if right click is down)
onmousedown = (e) => {
  o = true;
  if(e.which == 3){
    p = true;
  }
  else{
    p = false;
  }
}

// On mouse up, reset the mousedown flag
onmouseup = () => {
  o = false;
}

// On mouse move:
onmousemove = (e) => {
  
  // Compute mouse coords in px and in tiles
  x = e.pageX - a.getBoundingClientRect().left - document.documentElement.scrollLeft - document.body.scrollLeft;
  y = e.pageY - a.getBoundingClientRect().top - document.documentElement.scrollTop - document.body.scrollTop;
  q = Math.floor(x / 32);
  r = Math.floor((y - 40) / 32);
  
  // Level editor only
  if(d == 3){
    
    // Consider mousedown + mousemove like clicks (unless we're placing a pipe or a balance)
    if(o && A != 14 && A != 15){
      handle_clicks(e);
    }
    
    // In every case: redraw the d to show the tiles freshly placed and the tile being placed.
    draw_screen(1);
  }
}

// Handle clicks
handle_clicks = (e) => {
    
  // Main menu
  if(d == 0){

    // Button 1 (play): display level selection screen
    c.beginPath();
    c.rect(500, 400, 100, 80);
    if(c.isPointInPath(x, y)){
      d = 1;
      draw_screen();
    }
    c.closePath();
    
    // Button 2 (make): redirect to level editor
    c.beginPath();
    c.rect(650, 400, 100, 80);
    if(c.isPointInPath(x, y)){
      d = 3;
      reset_maker_level();
      draw_screen();
    }
    c.closePath();
  }
  
  // Level selection menu
  if(d == 1){
    
    // Back button
    c.beginPath();
    c.rect(30, 30, 50, 50);
    if(c.isPointInPath(x, y)){
      d = 0;
      draw_screen();
    }
    c.closePath();
    
    // G levels
    c.beginPath();
    c.rect(590, 520, 100, 80);
    if(c.isPointInPath(x, y)){
      open("http://goo.gl/oBx0S1");
    }
    c.closePath();
    
    // Levels
    for(i = 0; i < 10; i++){
      for(j = 0; j < 3; j++){
        m = j * 10 + i + 1;
        if(+localStorage["scpm"] >= m){
          c.beginPath();
          c.rect(i * 120 + 50, j * 100 + 120, 100, 80);
          if(c.isPointInPath(x, y)){
            n = 1;
            d = 2;
            _ = 0;
            s = m;
            t = levels[m];
            draw_screen();
          }
          c.closePath();
        }
      }
    }
  }
  
  // In-game
  if(d == 2 && N > 0){
    
    // Save click coordinates
    if(e.which == 1){
      O.C[N] = [x, y];
    }
    
    if(e.which == 3){
      O.z[N] = [x, y];
    }
    
    // Quit
    c.beginPath();
    c.rect(1240, 0, 32, 32);
    if(c.isPointInPath(x, y)){
      clearInterval(ad);
      d = n;
      draw_screen();
    }
    c.closePath();
  }
  
  // Level editor
  if(d == 3){
  
    // Build a hash with all the tiles #0 - #15 and #20 - #22 (i.e. all except pipes and pipe switches)
    t.hash = "";
    for(j = 0; j < 20; j++){
      for(i = 0; i < 40; i++){
        tile = t.x[j][i] || 0;
        tile = (tile < 16 || tile > 21) ? tile : 0;
        t.hash += String.fromCharCode(tile + 0x30);
      }
    }

    // Test
    c.beginPath();
    c.rect(750, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      n = 3;
      d = 2;
      draw_screen();
    }
    c.closePath();
    
    // Share
    c.beginPath();
    c.rect(875, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      location.hash = "";
      if(t.tested == false){
        alert("You need to test and I your level first.");
      }
      else {
        open("https://www.twitter.com/intent/tweet?text=" + encodeURIComponent("I made a level for #SuperChronoPortalMaker !\nPlay the game here: " + location.origin + location.pathname + ". \nPlay my level here:" + encodeURI(location.origin + location.pathname + "#" + JSON.stringify({hash:t.hash, pipes:t.pipes, balances: t.balances})) + "\nPlz RT"));
        G = true;
      }
    }
    c.closePath();
    
    // Clear
    c.beginPath();
    c.rect(1000, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      reset_maker_level();
      draw_screen();
    }
    c.closePath();
    
    // Exit
    c.beginPath();
    c.rect(1125, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      if(G || (!G && confirm("Quit? This level will be lost!"))){
        d = 0;
        draw_screen();
      }
    }
    c.closePath();
    
    // Tileset (choose a tile), unless we're placing a pipe or a balance
    for(i = 0; i < 16; i++){
      c.beginPath();
      c.rect(8.5 + i * 35, 3.5, 32, 32);
      if(c.isPointInPath(x, y) && pipe_click == 0 && w == 0){
        
        // Chosen tile
        H = true;
        A = i;
        
        // Pipe: init a pipe object
        if(A == 14){
          t.pipes[v] = [];
        }
        
        // Balance: init a balance object
        if(A == 15){
          t.balances[z] = [];
        }
        
        // Redraw entire screen (to show the active tile of the tileset)
        draw_screen();
      }
      c.closePath();
    }
    
    // Click on the grid (to place a tile)
    c.beginPath();
    c.rect(0, 40, 1280, 608);
    if(c.isPointInPath(x, y)){
      
      // Reset G flag
      if(H){
        G = false;
      }
      
      // Mark the level as untested because it has changed
      t.tested = false;
      
      // Save and draw placed tile.
      
      // Right click: erase (place sky / tile #0 instead of current tile)
      if(p == true){
        
        // Erase time machine
        // Top
        if(t.x[r][q] == 22){
          t.x[r][q] = 0;
          t.x[r + 1][q] = 0;
        }
        // Bottom
        if(t.x[r][q] == 23){
          t.x[r][q] = 0;
          t.x[r - 1][q] = 0;
        }
        
        // If the tile is writable
        if(is_writable(q, r)){
          t.x[r][q] = 0;
        }
        
        // Erase pipe if we click on tile #16 or #17 (pipe top)
        if(pipe_click == 0){
          if(t.x[r][q] == 16){
            for(i in t.pipes){
              if(t.pipes[i][0] == q && (t.pipes[i][1] == r || t.pipes[i][2] == r)){
                for(j = t.pipes[i][1]; j < 20; j++){
                  if(t.x[j][q] == 16 || t.x[j][q] == 18){
                    t.x[j][q] = 0;
                    t.x[j][q + 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                for(j = t.pipes[i][2]; j < 20; j++){
                  if(t.x[j][q] == 16 || t.x[j][q] == 18){
                    t.x[j][q] = 0;
                    t.x[j][q + 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                t.x[t.pipes[i][4]][t.pipes[i][3]] = 0;
                delete t.pipes[i];
              }
            }
          }
          
          if(t.x[r][q] == 17){
            for(i in t.pipes){
              if(t.pipes[i][0] == (q - 1) && (t.pipes[i][1] == r || t.pipes[i][2] == r)){
                for(j = t.pipes[i][1]; j < 20; j++){
                  if(t.x[j][q] == 17 || t.x[j][q] == 19){
                    t.x[j][q] = 0;
                    t.x[j][q - 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                for(j = t.pipes[i][2]; j < 20; j++){
                  if(t.x[j][q] == 17 || t.x[j][q] == 19){
                    t.x[j][q] = 0;
                    t.x[j][q - 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                t.x[t.pipes[i][4]][t.pipes[i][3]] = 0;
                delete t.pipes[i];
              }
            }
          }
          
          // Reorganize remaining pipes
          t.tmp = t.pipes;
          t.pipes = [];
          for(i in t.tmp){
            if(t.tmp[i]){
              t.pipes.push(t.tmp[i]);
            }
          }
        }
        
        // Erase balances if we click on tile #15
        if(w == 0){
          if(t.x[r][q] == 15){
            for(i in t.balances){
              if(
                (
                  t.balances[i][1] == r
                  &&
                  (
                    t.balances[i][0] == q
                    ||
                    t.balances[i][0] == q - 1
                    ||
                    t.balances[i][0] == q + 1
                  )
                )
                ||
                (
                  t.balances[i][3] == r
                  &&
                  (
                    t.balances[i][2] == q
                    ||
                    t.balances[i][2] == q - 1
                    ||
                    t.balances[i][2] == q + 1
                  )
                )
              ){
                t.x[t.balances[i][1]][t.balances[i][0]] = 0;
                t.x[t.balances[i][1]][t.balances[i][0] - 1] = 0;
                t.x[t.balances[i][1]][t.balances[i][0] + 1] = 0;
                
                t.x[t.balances[i][3]][t.balances[i][2]] = 0;
                t.x[t.balances[i][3]][t.balances[i][2] - 1] = 0;
                t.x[t.balances[i][3]][t.balances[i][2] + 1] = 0;
                
                delete t.balances[i];
              }
            }
          }
          
          // Reorganize remaining balances
          t.tmp = t.balances;
          t.balances = [];
          for(i in t.tmp){
            if(t.tmp[i]){
              t.balances.push(t.tmp[i]);
            }
          }
        }
      }
      
      // Left click
      else{
        
        // Special cases
        // Tile #1: allow only one time machine, below line 1
        if(A == 1){
          
          // If the two tiles are writable
          if(r > 0 && is_writable(q, r) && is_writable(q, r - 1)){
            for(j in t.x){
              for(i in t.x[j]){
                if(t.x[j][i] == 22 || t.x[j][i] == 23){
                  t.x[j][i] = 0;
                }
              }
            }
            t.x[r - 1][q] = 22;
            t.x[r][q] = 23;
          }
        }
        
        // Tile #2: only one flag
        else if(A == 2){
          
          // If the tile is writable
          if(is_writable(q, r)){
          
            for(j in t.x){
              for(i in t.x[j]){
                if(t.x[j][i] == 2){
                  t.x[j][i] = 0;
                }
              }
            }
            t.x[r][q] = 2;
          }
        }
        
        // Tile #14: pipe
        else if(A == 14){
          
          // If the two tiles are writable
          if(is_writable(q, r) && is_writable(q + 1, r)){
            
            // 1st click: set position 1 (x, y)
            if(pipe_click == 0){
              t.pipes[v] = [];
              t.pipes[v][0] = q;
              t.pipes[v][1] = r;
              t.x[r][q] = 16;
              t.x[r][q + 1] = 17;
              pipe_click ++;
            }
            
            // 2nd click: test if in-between tiles are writable and set position 2 (y)
            else if(pipe_click == 1){
              
              if(true){ // todo
                t.pipes[v][2] = r;
                t.x[r][t.pipes[v][0]] = 16;
                t.x[r][t.pipes[v][0] + 1] = 17;
                pipe_click ++;
              }
            }
            
            // 3rd click: set switch position (x, y)
            else if(pipe_click == 2){
              t.pipes[v][3] = q;
              t.pipes[v][4] = r;
              t.x[r][q] = 20;
              v++;
              pipe_click = 0;
            }
          }
        }
        
        // Tile #15: balanced platforms
        else if(A == 15){
          
          // If the three tiles are writable
          if(is_writable(q - 1, r) && is_writable(q, r) && is_writable(q + 1, r)){
            
            // 1st click: platform 1 (x, y)
            if(w == 0){
              t.balances[z] = [];
              t.balances[z][0] = q;
              t.balances[z][1] = r;
              w++
            }
            
            // 2nd click: set position 2 (x, y)
            else if(w == 1){
              t.balances[z][2] = q;
              t.balances[z][3] = r;
              z++;
              w = 0;
            }
            
            t.x[r][q - 1] = 15;
            t.x[r][q] = 15;
            t.x[r][q + 1] = 15;
          }
        }
        
        // Normal case: save current tile
        else if(is_writable(q, r)){
          t.x[r][q] = A;
        }      
      }
      
      // Map has been updated, redraw everything
      draw_screen(1);
    }
    c.closePath();
  }
}

// Keyboard input (during gameplay)
onkeydown = (e) => {
  if(d == 2){
    
    // Top
    if(e.keyCode == 38 || e.keyCode == 90 || e.keyCode == 87){
      if(O.n){
        O.m = true;
        O.n = false;
        aa = true;
      }
    }
    
    // Right
    if(e.keyCode == 39 || e.keyCode == 68){
      O.ac = true;
      ac = true;
    }
    
    // Left
    if(e.keyCode == 37 || e.keyCode == 65 ||e.keyCode == 81){
      O.ab = true;
      ab = true;
    }
  }
}

onkeyup = (e) => {
  
  // During gameplay
  if(d == 2){
    
    // Top
    if(e.keyCode == 38 || e.keyCode == 90 || e.keyCode == 87){
      O.m = false;
      O.n = true;
      aa = false;
    }
    
    // Right
    if(e.keyCode == 39 || e.keyCode == 68){
      O.ac = false;
      ac = false;
    }
    
    // Left
    if(e.keyCode == 37 || e.keyCode == 65 || e.keyCode == 81){
      O.ab = false;
      ab = false;
    }
    
    // R (reset)
    if(e.keyCode == 82){
      reset_current_level();
      _ = 0;
    }
    
    // Space (press to toggle between pick cube and drop cube)
    if(e.keyCode == 32){
      O.r[N] = true;
    }
    
    // Shift 
    if(e.keyCode == 16){
      O.shift[N] = true;
    }
  }
}

// Rendering
// =========

// Draw current screen (on load, when draw_screen is called, and when the hash changes)
// If no_reset is set, update the level editor without loading the map from the hash
draw_screen = onload = onhashchange = (no_reset) => {
  
  // Reset canvas
  a.width ^= 0;
  
  // Global text settings
  c.font = "bold 30px arial";
  c.textAlign = "center";
  
  // Pixelize graphics
  c["mozImageSmoothingEnabled"] = false;
  c["imageSmoothingEnabled"] = false;
  
  // Main menu
  // =========

  if(d == 0){
    
    // Cursor
    a.style.cursor = "pointer";
    
    // Background
    t = {hash:"0000==0000000000000000000000000000000000000====0000000000000000000000000000000000000000000000000000000000000000===000000000000000000000000000000000000=====00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000900000000000000059595000000000000000000000000000000000000000000000@A00000000000000000000000000000000000000BC00J00000000000000000000000000000000000BC03333333333333333333333333333333333333333",pipes:[[35,15,17,40,17]],balances:[]};

    ae = [,];
    first_N();
    parse_draw_map();
 
    // Show title
    c.drawImage(b, 512, 0, 70, 16, 120, 150, 280, 64);
    c.drawImage(b, 583, 0, 270, 16, 120, 250, 1080, 64);

    // Draw buttons
    c.fillStyle = "#000";
    c.beginPath();
    c.fillRect(500, 400, 100, 80);
    c.fillRect(650, 400, 100, 80);
    c.fillStyle = "#fff";
    c.fillText("MAKE", 700, 450);
    c.fillText("PLAY", 550, 450);
    c.stroke();
    c.closePath();
  }
  
  // Level selection menu
  if(d == 1){
    
    // Cursor
    a.style.cursor = "pointer";
    
    c.beginPath();
    c.fillStyle = "#000";
    c.fillRect(590, 520, 100, 80);
    k = 0;
    for(i = 0; i < 10; i++){
      for(j = 0; j < 3; j++){
        l = j * 10 + i + 1;
        c.fillStyle = "#000";
        c.fillRect(i * 120 + 50, j * 100 + 120, 100, 80);
        c.fillStyle = "#fff";
        c.fillText(+localStorage["scpm"] >= l ? l : "?", i * 120 + 100, j * 100 + 170);
        if(localStorage["scpm" + l] <= levels[l].record){
          c.fillText("🏅", i * 120 + 135, j * 100 + 145);
        }
        k += (+localStorage["scpm" + l] || 0);
      }
    }
    c.fillText("◀", 40, 70);
    c.fillText("JS13K LEVELS", 640, 70);
    c.fillText("TWITTER LEVELS", 640, 470);
    c.fillText("GO", 640, 570);
    c.fillStyle = "#000";
    if(k){
      c.fillText("Total time: " + ~~((k / 30) / 60) + ":" + ("0" + ((k / 30) % 60).toFixed(2)).slice(-5), 1100, 450);
    }
    c.stroke();
    c.closePath();
  }
  
  // Playing
  if(d == 2){
    
    // Cursor
    a.style.cursor = "crosshair";
    
    if(ad){
      clearInterval(ad);
    }
    reset_current_level();
    ad = setInterval(
    
    // Game ad
    // =========
    
    () => {

      // Reset canvas
      a.width ^= 0;
      
      // Draw exit button
      c.font = "bold 30px arial";
      c.fillStyle = "#000";
      c.fillText("×", 1255, 25);
      
      // First levels: add text
      if(n == 1){
        c.font = "bold 30px arial";
        c.fillStyle = "black";
        c.textAlign = "center";
        c.fillText(t.txt || "", 640, 80);
      }
      
      // Save keys being pressed (for latest Z only)
      if(O.ab){
        O.j[N] = true;
      }
      if(O.ac){
        O.g[N] = true;
      }
      if(O.m){
        O.l[N] = true;
      }
      
      // Pixelize graphics
      c.mozImageSmoothingEnabled = false;
      c.imageSmoothingEnabled = false;
      
      // On first N:
      // ---------------
      if(N == 0){
        
        // Init states of pipes, cubes, balances...
        first_N();
      }
      
      // Then, at each N:
      // --------------------
      
      // Move and draw pipes
      // For each pipe
      for(var i in t.pipes){
        
        // Go to position 2 when switch is pressed
        if(V[i].pressed){
          af = t.pipes[i][2] * 32;
        }
        
        // Go to position 1 when switch is not pressed
        else {
          af = t.pipes[i][1] * 32;
        }
          
        // Go up
        if(V[i].y > af){
          V[i].y = Math.max(V[i].y - 4, af);
        }
        
        // Go down
        else if(V[i].y < af){
          V[i].y = Math.min(V[i].y + 4, af);
        }

        // Draw pipe body (tiles #18 / #19)
        D = false;
        for(var k = ~~(V[i].y / 32) + 1; k < 21; k++){
          if(k < 20 && !is_Q(tile_at(t.pipes[i][0] * 32, k * 32)) && !is_Q(tile_at(t.pipes[i][0] * 32 + 1 * 32, k * 32)) && !D){
            draw_tile(18, t.pipes[i][0], k);
            draw_tile(19, t.pipes[i][0] + 1, k);
          }
          else{
            D = true;
            V[i].y_base = k * 32;
            break;
          }
        }
        
        // Draw pipe top (tiles #16 / #17)
        draw_sprite(16, t.pipes[i][0] * 32, V[i].y + 40);
        draw_sprite(17, t.pipes[i][0] * 32 + 32, V[i].y + 40);
        
        // Draw switch
        if(t.pipes[i][4]){
          
          if(V[i].pressed){
            draw_tile(21, t.pipes[i][3], t.pipes[i][4]);
          }
          else{
            draw_tile(20, t.pipes[i][3], t.pipes[i][4]);
          }
        }
      }
      
      // Draw map
      parse_draw_map();
      
      // Reset all mechanisms:
      
      // Reset yellow buttons
      R = false;
      for(j = 0; j < 20; j++){
        for(i = 0; i < 40; i++){
          if(t.x[j][i] == 25){
            t.x[j][i] = 11;
          }
        }
      }
      
      // Reset green buttons
      for(i in t.pipes){
        V[i].pressed = false;
      }
      
      O.weight = 1;
      
      for(i in t.u){
        t.u[i].weight = 1;
      }
      
      for(i in t.balances){
        W[i].weight1 = 0;
        W[i].weight2 = 0;
      }
      
      // Replay previous ae inputs
      for(Z in ae){
        play_Z(ae[Z], 1);
      }
      
      if(ae.length){
        Z = -1;
      }
      else{
        Z = 0;
      }
      
      // Play current Z
      play_Z(O);
      
      // Move and draw cubes
      for(i in t.u){
        
        // If cube is not in a #4 Q tile, assume it's not in a portal anymore
        if(
          tile_at(t.u[i].x + 1, t.u[i].y + 1) != 4
          &&
          tile_at(t.u[i].x + 32 - 1, t.u[i].y + 1) != 4
          &&
          tile_at(t.u[i].x + 1, t.u[i].y + 31) != 4
          &&
          tile_at(t.u[i].x + 32 - 1, t.u[i].y + 31) != 4
        ){
          t.u[i].k = false;
        }
        
        // Decrement teleportation idle delay
        if(t.u[i].c){
          t.u[i].c--;
        }  
        
        // Apply gravity and collsions if the cube is not held
        if(t.u[i].Z === null){
          if(!t.u[i].c && !is_Q(tile_at(t.u[i].x, t.u[i].y + 31)) && !is_Q(tile_at(t.u[i].x + 31, t.u[i].y + 31))){
            if(t.u[i].e > 1){
              t.u[i].e -= 1;
            }
            else if(t.u[i].e < -1){
              t.u[i].e += 1;
            }
            else{
              t.u[i].e = 0;
            }
          }
          gravity_and_collisions(t.u[i], 32, 1);
        }

        // Draw cube
        c.drawImage(b, 12 * 16, 0, 16, 16, t.u[i].x, 40 + t.u[i].y, 32, 32);
      }
        
      // Draw previous ae
      for(Z in ae){
        draw_Z(ae[Z], 1);
      }
      
      // Draw current Z
      draw_Z(O);
      
      // Draw tiles that have ag, and ag in foreground
      for(i in j = {"blue": X, "orange": Y }){
        draw_tile(4, j[i].q, j[i].r);
      }
        
      for(i in j = {"blue": X, "orange": Y }){

        c.fillStyle = i;
        
        if(j[i].side == 0){
          c.fillRect(j[i].q * 32, j[i].r * 32 + 40 - 8, 32, 8);
        }
        if(j[i].side == 1){
          c.fillRect(j[i].q * 32 + 28, j[i].r * 32 + 40, 8, 32);
        }
        if(j[i].side == 2){
          c.fillRect(j[i].q * 32, j[i].r * 32 + 40 + 28, 32, 8);
        }
        if(j[i].side == 3){
          c.fillRect(j[i].q * 32 - 4, j[i].r * 32 + 40, 8, 32);
        }
      }
      
      // Update mechanisms (yellow toggles / balances):
      // Apply yellow toggle (invert plain and transparent tiles if yellow toggle has changed during this N)
      if(R != U){
        mkaudio(SNDswitch0).play();
        for(j = 0; j < 20; j++){
          for(i = 0; i < 40; i++){
            if(t.x[j][i] == 9){
              t.x[j][i] = 10;
            }
            else if(t.x[j][i] == 10){
              t.x[j][i] = 9;
            }
          }
        }
      }
      
      // Save yellow toggle state 
      U = R;
      
      // Balances
      for(i in t.balances){
        
        // More weight on side 1 and no Q tile under platform 1 and no Q tile over platform 2
        if(
          W[i].weight1 > W[i].weight2
          && !is_Q(tile_at(t.balances[i][0] * 32 - 32, W[i].y1 + 20))
          && !is_Q(tile_at(t.balances[i][0] * 32, W[i].y1 + 20))
          && !is_Q(tile_at(t.balances[i][0] * 32 + 32, W[i].y1 + 20))
          && !is_Q(tile_at(t.balances[i][2] * 32 - 32, W[i].y2 - 4))
          && !is_Q(tile_at(t.balances[i][2] * 32, W[i].y2 - 4))
          && !is_Q(tile_at(t.balances[i][2] * 32 + 32, W[i].y2 - 4))
        ){
          W[i].y1 += 4;
          W[i].y2 -= 4;
        }
        
        // More weight on side 2 and no Q tile under platform 2 and no Q tile over platform 1
        else if(
          W[i].weight2 > W[i].weight1
          && !is_Q(tile_at(t.balances[i][2] * 32 - 32, W[i].y2 + 20))
          && !is_Q(tile_at(t.balances[i][2] * 32, W[i].y2 + 20))
          && !is_Q(tile_at(t.balances[i][2] * 32 + 32, W[i].y2 + 20))
          && !is_Q(tile_at(t.balances[i][0] * 32 - 32, W[i].y1 - 4))
          && !is_Q(tile_at(t.balances[i][0] * 32, W[i].y1 - 4))
          && !is_Q(tile_at(t.balances[i][0] * 32 + 32, W[i].y1 - 4))
        ){
          W[i].y1 -= 4;
          W[i].y2 += 4;
        }
        
        // Draw line
        c.beginPath();
        c.strokeStyle = "#fff";
        c.lineWidth = 2;
        c.moveTo(t.balances[i][0] * 32 + 16, W[i].y1 + 40 + 8);
        c.lineTo(t.balances[i][2] * 32 + 16, W[i].y2 + 40 + 8);
        c.stroke();
        c.closePath();
        
        // Draw balance 1
        draw_sprite(15, t.balances[i][0] * 32 - 32, W[i].y1 + 40);
        draw_sprite(15, t.balances[i][0] * 32, W[i].y1 + 40);
        draw_sprite(15, t.balances[i][0] * 32 + 32, W[i].y1 + 40);
        
        // Draw balance 2
        draw_sprite(15, t.balances[i][2] * 32 - 32, W[i].y2 + 40);
        draw_sprite(15, t.balances[i][2] * 32, W[i].y2 + 40);
        draw_sprite(15, t.balances[i][2] * 32 + 32, W[i].y2 + 40);
      }
      
      // Next N
      N++;
      
      // Chrono
      if(!I){
        _++;
      }
      
      // Victoty animation (if we won) / Game over animation (if we lose)
      c.font = "bold 100px arial";
      c.fillStyle = "#000";
      c.textAlign = "center";
      
      // I
      if(I){
        J++;
        c.fillText("CLEARED!", 640, 300);
        c.font = "bold 30px arial";
        if(n == 1){
          c.fillRect(450, 350, 400, 130);
          c.fillStyle = "#fff";
          document.title = _;
          c.fillText("Time: " + (_ / 30).toFixed(2) + "s", 640, 400);
          c.fillText("Dev record: " + (t.record / 30).toFixed(2) + "s", 640, 450);
          if(localStorage["scpm" + s]){
            localStorage["scpm" + s] = Math.min(+localStorage["scpm" + s], _);
          }
          else{
            localStorage["scpm" + s] = _;
          }
        }
      }
      
      // Current Z dies
      if(O.a == 3){
        K++;
        
        c.fillText("LOST!", 640, 350);
      }
      
      for(Z in ae){

        // Past Z dies or gets stuck (not at the time machine at the end of his N record)
        if(ae[Z].a == 3 || (ae[Z].p < N && !ae[Z].q && !I)){
          L++;
          c.fillText("PARADOX!", 640, 350);
        }
      }
      
      if(J == 1){
        mkaudio(SNDI0).play();
      }
      
      if(K == 1){
        mkaudio(SNDdie0).play();
      }
      
      if(L == 1){
        mkaudio(SNDglitch1).play();
      }
      
      if(K >= 30){
        a.width ^= 0;
        clearInterval(ad);
        d = n;
        t.tested = true;
        a.width ^= 0;
        draw_screen();
      }
      
      // Paradox (glitch)
      if(L){
        for(m = ~~(L / 5); m--;){
          c.drawImage(a, i = Math.random() * 1280, j = Math.random() * 648, k = Math.random() * 1280, l = Math.random() * 648, i + Math.random() * 100 - 50, j + Math.random() * 100 - 50, k, l);
        }
      }
      
      if(J >= 90){
        _ = 0;
        if(n == 1){
          s++;
          localStorage["scpm"] = Math.max(+localStorage["scpm"], s);
        }
        a.width ^= 0;
        clearInterval(ad);
        d = n;
        t.tested = true;
        a.width ^= 0;
        draw_screen();
      }
      
      if(K >= 30 || L >= 60){
        a.width ^= 0;
        clearInterval(ad);
        d = n;
        t.tested = false;
        a.width ^= 0;
        draw_screen();
      }
    }
    , 33);
  }
  
  // Level editor
  if(d == 3){
    
    // Cursor
    a.style.cursor = "pointer";
    
    c.strokeStyle = "#777";
    c.lineWidth = 1;
    
    // White BG (all screen)
    c.fillStyle = "#fff";
    c.fillRect(0, 0, 1280, 648);
    
    // Blue BG (tileset, grid)
    c.fillStyle = "#5C94FC";
    c.fillRect(0, 40, 1280, 640);
    
    c.beginPath();
    
    // Tileset
    for(i = 0; i < 16; i++){
      c.fillRect(8 + i * 35, 3, 32, 32);      
      c.rect(8 + i * 35, 3, 32, 32);
      draw_sprite(i, 8 + i * 35, 3);
    }
    
    c.stroke();
    c.closePath();
    
    // Tiles on grid
    if(!no_reset){
      if(t.hash){
        t.x = [];
        for(var j = 0; j < 20; j++){
          t.x[j] = [];
          for(var i = 0; i < 40; i++){
            t.x[j][i] = t.hash.charCodeAt(j * 40 + i) - 0x30;
          }
        }
      }
    }
  
    for(j = 0; j < t.x.length; j++){
      for(i = 0; i < t.x[j].length; i++){
        F = t.x[j][i];
        draw_tile(F, i, j);
        
        // Special cases
        
        // Tile #2: draw flag pole
        if(F == 2){
          E = false;
          if(j < 20){
            for(k = j + 1; k < 20; k++){
              if(!t.x[k][i] && !E){
                draw_tile(24, i, k);
              }
              else{
                E = true;
              }
            }
          }
        }
      }
    }
    
    // Pipes
    for(i in t.pipes){
      
      C = t.pipes[i][1];
      
      // If the two positions of the pipe were placed
      if(t.pipes[i][2]){
        
        // Pipe body between low ang high (we save it in the map to avoid overwrite)
        B = t.pipes[i][1] < t.pipes[i][2] ? t.pipes[i][1] : t.pipes[i][2];
        C = t.pipes[i][1] < t.pipes[i][2] ? t.pipes[i][2] : t.pipes[i][1];
        for(k = B + 1; k < C; k++){
          draw_tile(18, t.pipes[i][0], k);
          draw_tile(19, t.pipes[i][0] + 1, k);
          t.x[k][t.pipes[i][0]] = 18;
          t.x[k][t.pipes[i][0] + 1] = 19;
        }
      }
      
      // If the first position of the pipe was placed
      if(t.pipes[i][1]){
        
        // Pipe body below low position (can be overwritten)
        D = false;
        for(k = C + 1; k < 21; k++){
          if(k < 20 && !t.x[k][t.pipes[i][0]] && !t.x[k][t.pipes[i][0] + 1] && !D){
            draw_tile(18, t.pipes[i][0], k);
            draw_tile(19, t.pipes[i][0] + 1, k);
          }
          else{
            D = true;
          }
        }
      }
      
      // Pipe position 1
      if(t.pipes[i][1]){
        draw_tile(16, t.pipes[i][0], t.pipes[i][1]);
        draw_tile(17, t.pipes[i][0] + 1, t.pipes[i][1]);
        t.x[t.pipes[i][1]][t.pipes[i][0]] = 16;
        t.x[t.pipes[i][1]][t.pipes[i][0] + 1] = 17;
        
      }
      
      // Pipe position 2
      if(t.pipes[i][2]){
        draw_tile(16, t.pipes[i][0], t.pipes[i][2]);
        draw_tile(17, t.pipes[i][0] + 1, t.pipes[i][2]);
        t.x[t.pipes[i][2]][t.pipes[i][0]] = 16;
        t.x[t.pipes[i][2]][t.pipes[i][0] + 1] = 17;
      }
      
      // Switch
      if(t.pipes[i][4]){
        draw_tile(20, t.pipes[i][3], t.pipes[i][4]);
      }
    }
    
    // Balances
    for(i in t.balances){
      
      // Draw line and balance 2
      if(t.balances[i][3]){
        
        // Draw line
        c.beginPath();
        c.strokeStyle = "#fff";
        c.lineWidth = 2;
        c.moveTo(t.balances[i][0] * 32 + 16, t.balances[i][1] * 32 + 40 + 8);
        c.lineTo(t.balances[i][2] * 32 + 16, t.balances[i][3] * 32 + 40 + 8);
        c.stroke();
        c.closePath();
      
        // Balance 2
        draw_tile(15, t.balances[i][2] - 1, t.balances[i][3]);
        draw_tile(15, t.balances[i][2], t.balances[i][3]);
        draw_tile(15, t.balances[i][2] + 1, t.balances[i][3]);
        
        t.x[t.balances[i][3]][t.balances[i][2] - 1] = 15;
        t.x[t.balances[i][3]][t.balances[i][2]] = 15;
        t.x[t.balances[i][3]][t.balances[i][2] + 1] = 15;
      }
      
      // Draw balance 1
      if(t.balances[i][1]){
        draw_tile(15, t.balances[i][0] - 1, t.balances[i][1]);
        draw_tile(15, t.balances[i][0], t.balances[i][1]);
        draw_tile(15, t.balances[i][0] + 1, t.balances[i][1]);
        
        t.x[t.balances[i][1]][t.balances[i][0] - 1] = 15;
        t.x[t.balances[i][1]][t.balances[i][0]] = 15;
        t.x[t.balances[i][1]][t.balances[i][0] + 1] = 15;
      }
    }
    
    
    // Show the tile being placed:
    if(r >= 0 && !p){
      
      // Special cases:
      // Tile #1: time machine
      if(A == 1){
        if(r > 0){
          draw_tile(22, q, r - 1);
          draw_tile(23, q, r);
        }
      }
      
      // Tile #14: pipe
      else if(A == 14){
        if(pipe_click == 0){
          draw_tile(16, q, r);
          draw_tile(17, q + 1, r);
        }
        if(pipe_click == 1){
          draw_tile(16, t.pipes[v][0], r);
          draw_tile(17, t.pipes[v][0] + 1, r);
        }
        if(pipe_click == 2){
          draw_tile(20, q, r);
        }
      }
      
      // Tile #15: balance
      else if(A == 15){
        draw_tile(15, q - 1, r);
        draw_tile(15, q, r);
        draw_tile(15, q + 1, r);
      }
      
      // Normal case:
      else {
        draw_tile(A, q, r);
      }
    }
    
    // Grid
    c.beginPath();
    c.strokeStyle = "#777";
    c.lineWidth = 1;
    for(i = 0; i < 40; i++){
      c.moveTo(i * 32, 40);
      c.lineTo(i * 32, 648);
    }
    for(j = 0; j < 20; j++){
      c.moveTo(0, 40 + j * 32);
      c.lineTo(1280, 40 + j * 32);
    }
    
    // Buttons
    c.fillStyle = "#000";
    c.fillRect(750, 4, 100, 32);
    c.fillRect(875, 4, 100, 32);
    c.fillRect(1000, 4, 100, 32);
    c.fillRect(1125, 4, 100, 32);
    c.fillStyle = "#fff";
    c.font = "bold 20px arial";
    c.fillText("TEST", 800, 28);
    c.fillText("SHARE", 925, 28);
    c.fillText("CLEAR", 1050, 28);
    c.fillText("EXIT", 1175, 28);
    c.stroke();
    c.closePath();
    
    // Current tile on the tileset
    c.beginPath();
    i = A;
    c.strokeStyle = "red";
    c.lineWidth = 3;
    c.rect(8 + i * 35, 3.5, 32, 32);
    c.stroke();
    c.closePath();
  }
}

// Hash (G levels)
// ====================

// If a hash is set, play the level directly
onhashchange = () => {
  if(location.hash){
    t = JSON.parse(decodeURIComponent(location.hash.slice(1)));
    d = 2;
    draw_screen();
  }
}

onhashchange();

// Sound
// =====

mkaudio = (fn) => {
	var data = [];
	for (var i = 0;;i++) {
		var smp = fn(i);
		if (smp===null) break;
		data.push(smp);
	}
	var l = data.length;
	var l2=l*2;

	var b32 = v => {
		var s = 0;
		var b = "";
		for (var i=0; i<4; i++,s+=8) b+=String.fromCharCode((v>>s)&255);
		return b;
	};
	var b16 = (v) => {
		var b = b32(v);
		return b[0]+b[1];
	};

	var SR=48e3;
	var b = "RIFF"+b32(l2+36)+"WAVEfmt "+b32(16)+b16(1)+b16(1)+b32(SR)+b32(SR*2)+b16(2)+b16(16)+"data"+b32(l2);
	for (var i in data) b+=b16(data[i]*10e3);
	return new Audio("data:audio/wav;base64,"+btoa(b));
}

P=Math.pow;
S=Math.sin;

T = (i,n) => {
	return (n-i)/n;
}

SNDjump2 = (i) => {
	i=i*1.5;
	var n = 2e4;
	if (i>n) return null;
	return ((P(i,1.075)&128)?1:-1)*P(T(i,n),2);
}

SNDdie0 = (i) => {
	var n=5e4;
	if (i > n) return null;
	return ((P(i,0.9)&200)?1:-1)*P(T(i,n),3);
}

SNDbrick1 = (i) => {
	var n=5e3;
	if (i > n) return null;
	return ((P(i+S(i*0.01)*1000,0.8)&200)?0.5:-0.5)*P(T(i,n),1);
}

SNDglitch1 = (i) => {
	var n=9e4;
	if (i > n) return null;
	return ((P(i+S(i*0.01)*1000,0.8)&200)?0.5:-0.5)*P(T(i,n),1);
}

SNDcoin1 = (i) => {
	var n=1.6e4;
	var c=n/7;
	if (i > n) return null;
	var q=P(T(i,n),2.1);
	return (i<c ? ((i+S(-i/900)*10)&16) : i&13) ?q:-q;
}

SNDI0 = (i) => {
	var notes = [0,4,7,12,undefined,7,12];
	var n=4e4;
	if (i > n) return null;
	var idx = ((notes.length*i)/n)|0;
	var note = notes[idx];
	if (note === undefined) return 0;
	var r = P(2,note/12)*0.8;
	var q = T((i*notes.length)%n,n);
	return ((i*r)&64)?q:-q
}

SNDswitch0 = (i) => {
	var n=7e3;
	if (i > n) return null;
	return ((((i^(i>>3))^(i*i*7.3)^(i<<4))&65535)/65536)*T(i,n);
}

SNDtimetravel0 = (i) => {
	var n=5e4;
	var n1=1e5;
	if (i > n) return null;
	i=P(i,1.2-S(i/n1))*7;
	var x=S(i/30+S(i/1500));
	return P(x,9)*T(i,n);
}
</script>